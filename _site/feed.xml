<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leezw Blog</title>
    <description>be a better man</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 01 Feb 2018 17:13:57 +0800</pubDate>
    <lastBuildDate>Thu, 01 Feb 2018 17:13:57 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>闲时写的小工具-接口文档转property</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Yeh 我又写了小东西&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;起因&quot;&gt;起因&lt;/h1&gt;

&lt;p&gt;在给app写请求接口时候，通常我们都会吧最终要返回的json数据用一个对象来接受，其中的json转模型的工作已经有很多大神帮我们提供了很多工具，但是发现最烦的工作其实是在写模型的时候，当创建模型对象后，操作基本就是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;切换到 接口文档 command+c，切换到 模型文件 command+v&lt;/li&gt;
  &lt;li&gt;切换到 接口文档 command+c，切换到 模型文件 command+v&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当参数多的时候，还要防止看串行，这种毫无技术含量的事情，既繁琐，又费时。&lt;br /&gt;
于是我便有了写个转换工具的想法，具体功能就是，吧接口文档的参数全扔进去，然后输出生成好的属性代码，复制到模型对象就好了.&lt;/p&gt;

&lt;h1 id=&quot;实现&quot;&gt;实现&lt;/h1&gt;

&lt;p&gt;由于公司没有规范的文档格式，所以得考虑 后台大大 们的各种写法，末尾带分号的，末尾//注释的，单行注释的，一会小写一会大写的……&lt;br /&gt;
基本的匹配格式是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[空格*n]+类型+[空格*n]+字段名+[注释]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基本的界面格式大概是：左侧为输入框，右侧为输出框，&lt;/p&gt;

&lt;p&gt;交互包括：清空输入框，转换，复制输出内容&lt;/p&gt;

&lt;h1 id=&quot;效果&quot;&gt;效果&lt;/h1&gt;

&lt;p&gt;正常使用效果：
&lt;img src=&quot;/img/articles/2018-1-31_interface/img1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;各种输入格式的转换效果：
&lt;img src=&quot;/img/articles/2018-1-31_interface/img2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Baymax0/MacPropertyTranslater&quot;&gt;工具的github地址&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Wed, 31 Jan 2018 17:54:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/31/interface/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/31/interface/</guid>
        
        <category>mac工具</category>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS通讯录拼音分组排序</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在实现好友列表或通讯录功能时，我们大多需要对名字进行拼音排序及分组，后来在网上发现了&lt;a href=&quot;https://github.com/6357/YUChineseSorting.git&quot;&gt;YUChineseSorting&lt;/a&gt;已经实现了基本的字符串排序算法。但是它只能对字符串数组进行分组排序，并且还需要加入.cpp文件，使用比较麻烦。于是我在原来基础上对代码进行封装，支持了对对象数组按对象的某个属性进行排序。并对原来的代码进行了合并和封装，比原来使用更方便。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;

&lt;p&gt;在Objective C语言中，字符串是以unicode进行编码的。在unicode字符集中，汉字的编码范围为4E00(16进制) 到 9FA5(16进制) 之间（即从第19968开始的20902个字符是中文简体字符）。YUChineseSorting把这些字符的拼音首字母按照原来的顺序都存放在一个char数组中。当我们查找一个汉字的拼音首字母时，只需把这个汉字的unicode码（即char强制转换为int）减去19968，然后用这个数字作为索引去找char数组中存放的字母即可。比较野蛮的一个方法。&lt;/p&gt;

&lt;h3 id=&quot;调用方法介绍&quot;&gt;调用方法介绍&lt;/h3&gt;

&lt;p&gt;首先吧BMChineseSort.h及.m文件导入到项目中，只需要这两文件。
对自定义对象数组排序需要只需要使用两类个方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+(NSMutableArray*)IndexWithArray:(NSArray*)objectArray Key:(NSString *)key;
+(NSMutableArray*)sortObjectArray:(NSArray*)objectArray Key:(NSString *)key;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一个方法：一个参数objectArray是自定义对象数组，另一个参数key是数组里需要排序的字段名字。方法返回所有出现过的首字母，用于显示在tableview的head以及右侧索引缩写。&lt;/p&gt;

&lt;p&gt;第二个方法：，是根据对象的某个字段值对整个数组进行排序，首先，先将字段首字母拼音相同的对象存到同一个数组里，然后把所有的数组再放到结果数组里。&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1640181-42fd65f8dd151a40.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;
获得的两个数组在tableview代理方法中的具体使用可以参考我的demo，已上传到github。&lt;/p&gt;
&lt;h3 id=&quot;具体tableview设置&quot;&gt;具体tableView设置&lt;/h3&gt;

&lt;h6 id=&quot;person对象&quot;&gt;Person对象：&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assign&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;通讯录控制器viewdidload方法&quot;&gt;通讯录控制器viewDidLoad方法：&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// array是NSArray&amp;lt; Person *&amp;gt;类型的模拟数据
self.indexArray = [BMChineseSort IndexWithArray:array Key:@&quot;name&quot;];
self.letterResultArr = [BMChineseSort sortObjectArray:array Key:@&quot;name&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;tableview代理方法&quot;&gt;TableView代理方法：&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//section的titleHeader
- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section {
    return [self.indexArray objectAtIndex:section];
}
//section行数
-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{
    return [self.indexArray count];
}
//每组section个数
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{
    return [[self.letterResultArr objectAtIndex:section] count];
}
//section右侧index数组
-(NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView{
    return self.indexArray;
}
//点击右侧索引表项时调用 索引与section的对应关系
- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index{
    return index;
}
//返回cell
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;CELL&quot;];
    if (cell == nil){
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;CELL&quot;];
    }
    //获得对应的Person对象
    Person *p = [[self.letterResultArr objectAtIndex:indexPath.section] objectAtIndex:indexPath.row];
    cell.textLabel.text = p.name;
    return cell;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;附&quot;&gt;附：&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Baymax0/BMChineseSort&quot;&gt;BMChineseSort使用Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kuku/archive/2012/08/19/2646063.html&quot;&gt;IOS数组按中文关键字以字母序排序&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Wed, 31 Jan 2018 17:44:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/31/pingying/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/31/pingying/</guid>
        
        <category>mac工具</category>
        
        
      </item>
    
      <item>
        <title>自定义ViewController的跳转动画</title>
        <description>&lt;p&gt;在学习iOS动画时看到，别人炫酷的动画效果一直是我学习的动力，在学习如何自定义后发现其实并没那么难，一些渐变，翻转，平移等在UIView上能实现的动画都可以放到跳转动画里，做完例子你也可以，分享一个github上别人做的炫酷的动画效果：&lt;a href=&quot;https://github.com/shu223/AnimatedTransitionGallery&quot;&gt;github地址&lt;/a&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1640181-8f6e494722bd2429.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;https://github.com/shu223/AnimatedTransitionGallery&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;当我们进行视图切换的时候，无论是push，pop还是通过PresentModal和dismiss时，我们可以把跳转动画分割为三个部分，
1：第一个视图控制器显示。
2：临时视图控制器  显示动画效果（并不是真的存在这个控制器，其实只有一个containerView）
3：显示第二个视图控制器。
用形象一点的说法，我们可以将第二部分也看做是一个临时的视图控制器，他执行一段关于UIView的动画，我们只要让动画的开始界面与控制器1一样，结束界面与视图控制器2一样。当动画执行结束，执行到第三步时，把临时的视图控制器释放。这样只要稍微实现一些UIView，CALayer的动画，
具体的实现方法以下图的效果为例子：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1640181-fcf8d0ee3b7b7c32.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;跳转动画Demo.gif&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;用到的协议及方法&quot;&gt;用到的协议及方法&lt;/h2&gt;

&lt;h6 id=&quot;protocol-uiviewcontrolleranimatedtransitioning&quot;&gt;@protocol UIViewControllerAnimatedTransitioning&lt;/h6&gt;

&lt;p&gt;实现这个协议的对象就相当于是之前说到的临时视图控制器，协议中主要用到的两个方法是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//这个方法中我们只要返回页面跳转动画的执行时间
-(NSTimeInterval)transitionDuration:(id &amp;lt; UIViewControllerContextTransitioning &amp;gt;)transitionContext;
//在这个方法中实现具体动画
-(void)animateTransition:(id &amp;lt; UIViewControllerContextTransitioning &amp;gt;)transitionContext;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第二个方法是跳转动画核心内容，方法中的参数transitionContext是当前临时控制器界面的上下文。通过上下文，我们先拿到临时视图控制器的背景视图containerView，他已经有一个子视图，即fromViewController.view。我们要做的是，先获得toViewController&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; 然后把当前视图加到内容视图上

[[transitionContext containerView] addSubview:toVC.view]; 剩下的部分就可以发挥我们的系统核心动画的学习水平，比如修改toVC.view的frame，从下方旋转弹出等等。而要实现Demo里的效果，我们需要CAShapeLayer来给toView做遮挡，然后从修改ShapeLayer.path属性，从一个小圆变成一个囊括全屏的大圆，小圆大圆我们通过UIBezierPath画出来，对于ShapeLayer和UIBezierPath不熟悉的同学可以先去补习一下，这里具体的使用也不复杂，也可以直接看下面的代码学习。

//应用程序的屏幕高度
#define kWindowH   [UIScreen mainScreen].bounds.size.height
//应用程序的屏幕宽度
#define kWindowW    [UIScreen mainScreen].bounds.size.width   #  
_circleCenterRect = CGRectMake(120, 320, 50, 50);
//圆圈1--小圆
UIBezierPath *smallCircleBP =  [UIBezierPath bezierPathWithOvalInRect:_circleCenterRect];
//圆圈2--大圆
//以_circleCenterRect的中心为圆心
CGFloat centerX = _circleCenterRect.origin.x+_circleCenterRect.size.width/2;
CGFloat centerY = _circleCenterRect.origin.y+_circleCenterRect.size.height/2;
//找出圆心到页面4个角 最长的距离 作为半径
CGFloat r1 = (kWindowW-centerX)&amp;gt;centerX?(kWindowW-centerX):centerX;
CGFloat r2 = (kWindowW-centerY)&amp;gt;centerY?(kWindowW-centerY):centerY;
CGFloat radius = sqrt((r1 * r1) + (r2 * r2));
UIBezierPath *bigCircleBP = [UIBezierPath bezierPathWithOvalInRect:CGRectInset(_circleCenterRect, -radius, -radius)]; 画完圆后通过CABasicAnimation执行：

//设置maskLayer
CAShapeLayer *maskLayer = [CAShapeLayer layer];//将它的 path 指定为最终的 path 来避免在动画完成后会回弹
toVC.view.layer.mask = maskLayer;
maskLayer.path = bigCircleBP.CGPath;
//执行动画
CABasicAnimation *maskLayerAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];
maskLayerAnimation.fromValue = (__bridge id)(smallCircleBP.CGPath);
maskLayerAnimation.toValue = (__bridge id)((bigCircleBP.CGPath));
maskLayerAnimation.duration = [self transitionDuration:transitionContext];
maskLayerAnimation.delegate = self;
[maskLayer addAnimation:maskLayerAnimation forKey:@&quot;path&quot;]; 返回时候的动画效果和上面的代码基本相同，只用将大圆和小圆的顺序对调，完成了跳转动画最核心的部分后就是怎么使用这个对象了，无论是navigation和模态跳转，系统都给我们提供了回调方法，我们只需要实现方法，然后把我们之前写好的动画对象返回就可以了。由于给视图添加了shapelayer，可以在CABasicAnimation的代理方法里实现。

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{
    //告诉 系统这个 transition 完成
    [self.transitionContext completeTransition:![self.transitionContext transitionWasCancelled]];
    //清除 fromVC 的 mask
    [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey].view.layer.mask = nil;
    [self.transitionContext viewControllerForKey:UITransitionContextToViewControllerKey].view.layer.mask = nil;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;protocol-uinavigationcontrollerdelegate&quot;&gt;@protocol UINavigationControllerDelegate&lt;/h6&gt;

&lt;p&gt;这是修改Navigation跳转动画需要实现的协议，当我们通过pop或者push进行跳转时，都会调用下面的方法(协议的其他方法由于暂时用不到，所以就不介绍了)，我们可以看到返回值是id &lt;UIViewControllerAnimatedTransitioning&gt;，就是我们之前编写的动画对象。
    - (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                                   animationControllerForOperation:(UINavigationControllerOperation)operation
                                                fromViewController:(UIViewController *)fromVC
                                                  toViewController:(UIViewController *)toVC;
方法中的operation参数是一个枚举类型，我们可以判断它的值是 UINavigationControllerOperationPush还是
    UINavigationControllerOperationPop来区别当前的跳转方式。&lt;/UIViewControllerAnimatedTransitioning&gt;&lt;/UIViewControllerAnimatedTransitioning&gt;&lt;/p&gt;

&lt;h6 id=&quot;protocol-uiviewcontrollertransitioningdelegate&quot;&gt;@protocol UIViewControllerTransitioningDelegate&lt;/h6&gt;

&lt;p&gt;这是修改模态跳转动画需要实现的协议，我们进行跳转PresentModal和dismiss时会分别调用两个方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//PresentModal跳转回调方法
- (nullable id &amp;lt;UIViewControllerAnimatedTransitioning&amp;gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;
//dismiss跳转回调方法
- (nullable id &amp;lt;UIViewControllerAnimatedTransitioning&amp;gt;)animationControllerForDismissedController:(UIViewController *)dismissed; 这两个方法的返回值和上面navigation回调方法的返回值一样，我们只需要初始化我们的实现了UIViewControllerTransitioningDelegate协议的动画对象就可以了。具体的实现以及效果可以查看文章末尾附上的Demo。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;navigation跳转需要注意的地方&quot;&gt;navigation跳转需要注意的地方&lt;/h6&gt;

&lt;p&gt;在使用Navigation跳转的时候，我们希望视图1跳转到视图2和视图2返回视图1有自定义动画时，我们只用在视图1中将设置视图1的navigation的delagate。其次delegate的设置最好放在viewWillAppear中。&lt;/p&gt;

&lt;p&gt;demo所实现的最终效果只出现在点击按钮时的跳转动画，而不包括像navigation侧滑返回那样的手势动画。如何怕侧滑效果不统一，我们可以先把侧滑返回的效果关闭：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.navigationController.interactivePopGestureRecognizer.enabled = NO;  &amp;gt;// TODO：手势跳转动画实现方法（坑 待填）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Baymax0/MySampleDemo/tree/master&quot;&gt;Demo地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/ea0132738057&quot;&gt;bestswifter 的swift版教程&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Wed, 31 Jan 2018 17:35:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/31/transitioningAnimation/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/31/transitioningAnimation/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Block是如何实现的，以及block中参数传递</title>
        <description>&lt;p&gt;先看下面的一段代码，判断输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a = 0;  
void (^block)(void) = ^{
    printf(&quot;a = %i\n&quot;,a);
};
a=10;
block();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;经过运行之后我们发现，输出结果为“a = 0”,而不是”a = 10”。
如果感觉答案是“a = 10”的同学看下面的代码或许会有所感觉，明显会报错，提示“Use of undeclared identifier ‘a’ ”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void (^block)(void) = ^(){printf(&quot;a = %i\n&quot;,a);};
int a=10;
block();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们发现block块在初始化的时候就要获取局部变量（局部变量）a的值，之后a的值的变化并不会影响block的运行结果。&lt;/p&gt;

&lt;p&gt;*所说的局部变量为block外的局部变量，而非block内定义的。&lt;/p&gt;

&lt;h2 id=&quot;block结构&quot;&gt;Block结构：&lt;/h2&gt;

&lt;p&gt;到底block是如何实现的呢？下面是一个最简单的block的定义与使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc, const char * argv[]) {
    void (^block)(void) = ^{printf(&quot;This is a block！&quot;);};
    block();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过终端，我们找到main.m文件所在路径，然后输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -rewrite-objc main.m
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;（通过clang编译器，我们可以获得在编译过程中生产的中间代码，看block时如何实现的）&lt;br /&gt;
在当前目录下找到main.cpp文件，打开后能看到block生成了很多结构体如下：（简化后的代码,可查找关键字），&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct __block_impl {
    void *isa;//block存放位置，取值为_NSConcretGlobalBlock(全局区)、_NSConcretStackBlock(栈区)、_NSConcretMallocBlock(堆区)
    int Flags;//用于按bit位表示一些block的附加信息，block copy的实现代码可以看到对该变量的使用。
    int Reserved;//保留变量。
    void *FuncPtr;
};

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    printf(&quot;This is a block！&quot;);
}

struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { //构造函数
        impl.isa = &amp;amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};

int main(int argc, const char * argv[]) {
    void (*block)(void) = (void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA);
    ((void (*)(__block_impl *))((__block_impl *)block)-&amp;gt;FuncPtr)((__block_impl *)block);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看上去很多，其实没那么难理解，一个一个来分别介绍他们的意思：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;__block_impl：block的一些基础属性，像是block的基类。&lt;/li&gt;
  &lt;li&gt;__main_block_desc_0：block的描述，他有一个实例__main_block_desc_0_DATA&lt;/li&gt;
  &lt;li&gt;__main_block_impl_0：block变量（包含上面两个结构体对象）。&lt;/li&gt;
  &lt;li&gt;__main_block_func_0：block的匿名函数。存放block内的语句。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;命名规则：“main”为block所在函数名，如果定义在函数外为block的名字，末尾的“0”表示为当前函数中第“0”个block。&lt;/p&gt;

&lt;p&gt;在末尾的main函数中，我们可以看到block的初始化是调用__main_block_impl_0的构造函数，所以block的内容简化后为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct __main_block_impl_0 {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
    size_t reserved;
    size_t Block_size;
    __main_block_impl_0(#block匿名函数的指针#,#__main_block_desc_0的实例指针#, int flags=0);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由此可见：block其实就是一个Object-c对象。&lt;/p&gt;

&lt;h2 id=&quot;局部变量&quot;&gt;局部变量：&lt;/h2&gt;

&lt;p&gt;通过clang -rewrite-objc 指令编译本文开头的那段代码我们找出与之前的编译结果的不同：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct __main_block_impl_0 {
    struct __block_impl impl;       
    struct __main_block_desc_0* Desc;
    int a; 
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
        impl.isa = &amp;amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
//block的匿名函数
static void __main_block_func_0(struct __main_block_impl_0 *__cself){
    int a = __cself-&amp;gt;a; // bound by copy
    printf(&quot;a = %i\n&quot;,a);
}
//主方法
int main(int argc, const char * argv[]) {
    int a = 0;
    //block初始化
    void (*block)(void) = (void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA, a);
    a=10;
    //block调用
    ((void (*)(__block_impl *))((__block_impl *)block)-&amp;gt;FuncPtr)((__block_impl *)block);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;比较后发现：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;__main_block_impl_0的属性中多了一个变量a；&lt;/li&gt;
  &lt;li&gt;__main_block_impl_0初始化方法的参数中也有接收变量对a赋值的方法。&lt;/li&gt;
  &lt;li&gt;__main_block_func_0而在匿名函数中多了一行“int a = __cself-&amp;gt;a;”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;局部变量的传递的实现方法，当block在初始化的时候，通过构造函数把a的值通过值传递传入block，而在__main_block_func_0方法中，通过int a创建变量来接收。最后在匿名函数中使用时又创建临时变量类获得a。所以在block执行时，输出的a为block初始化时获得的a的值，使用的是a的副本。&lt;/p&gt;

&lt;p&gt;这也能说明为什么，block中不让修该局部变量。首先在block中修改局部变量的值本是没问题的，但是修改的只是和局部变量名字一样的副本变量的值，这并不会影响局部变量本来的值。为了不让开发者迷惑，所以就不让赋值。&lt;/p&gt;

&lt;p&gt;那么如果获取的局部变量是OC对象呢&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc, const char * argv[]) {
    NSMutableArray *array = [[NSMutableArray alloc] initWithCapacity:0];
    void (^block)(void) = ^{
        [array addObject:@&quot;block&quot;];
    };
    block();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这么写是能运行的，因为array是一个指针，我们并没有改变指针的值。&lt;/p&gt;

&lt;h2 id=&quot;static修饰符与全局变量&quot;&gt;static修饰符与全局变量&lt;/h2&gt;

&lt;p&gt;全局变量或静态变量都在全局区，在内存中的地址是固定的，Block在初始化时读取的是该变量值地址，当调用的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。而且可以在block中修改他们的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a=0;
int main(int argc, const char * argv[]) {
    static int b=0;
    void (^block)(void) = ^{
        NSLog(@&quot;a=%i,b=%i&quot;,++a,++b);
    };
    a = 10;
    b = 10;
    block();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行的结果为（不是“a=1,b=1”）：    a=11,b=11&lt;/p&gt;

&lt;h2 id=&quot;__block修饰符&quot;&gt;__block修饰符&lt;/h2&gt;

&lt;p&gt;之前了解了block中用到局部变量时，使用的是局部变量的副本，当我们要想局部变量能在block中进行修改时，我们通常会在局部变量前写上__block修饰符，那么它又是如何实现的呢。对如下代码进行编译：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc, const char * argv[]) {
    __block int a=0;
    void (^block)(void) = ^{printf(&quot;a = %i&quot;,++a);};
    block();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编译后的代码简化为（只列出有变化的部分）
    struct __Block_byref_a_0 {
        void *__isa;
        __Block_byref_a_0 *__forwarding;
        int __flags;
        int __size;
        int a;
    };&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __Block_byref_a_0 *a; // by ref
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&amp;gt;__forwarding) {
        impl.isa = &amp;amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    __Block_byref_a_0 *a = __cself-&amp;gt;a; // bound by ref
    printf(&quot;a = %i&quot;,++(a-&amp;gt;__forwarding-&amp;gt;a));}

static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;amp;dst-&amp;gt;a, (void*)src-&amp;gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&amp;gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

int main(int argc, const char * argv[]) {
    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;amp;a, 0, sizeof(__Block_byref_a_0), 0};
    void (*block)(void) = (void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;amp;a, 570425344);
    ((void (*)(__block_impl *))((__block_impl *)block)-&amp;gt;FuncPtr)((__block_impl *)block);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们发现多了很多东西，看上去很乱，我们一个一个来，首先我们看主函数main里第一行，由__block int a=0;编译而来。当我们为局部变量加上__block修饰符时，编译器会自动创建一个关于这个变量的结构体__Block_byref_a_0，而变量的初始化，变为结构体的初始化，将局部变量对象化了。
在关于变量a的结构体__Block_byref_a_0中，有“int a；”用于存放变量值，有“__Block_byref_a_0 *__forwarding;”一个关于自己的指针，以及其他一些属性。而block初始化时，将对象化后的a作为了构造函数的参数。由之前分析我们已经得知如果block获取的局部变量是OC对象，是可以对它进行操作的。&lt;/p&gt;

&lt;h2 id=&quot;为什么不直接创建变量a的指针&quot;&gt;为什么不直接创建变量a的指针&lt;/h2&gt;

&lt;p&gt;到这里应该理解了__block的实际工作，但是肯定会有人疑惑，说到底，将a对象化的目的只是因为对象传递得时候传的是指针，那么为什么不直接创建一个指针指向变量a，而要将他对象化。说到这里就要先说说内存中栈和堆，函数内局部变量的初始化是分配到栈中，而对象的初始化是分配在堆中（ios中alloc都是存放在堆中），变量a是分配在栈中，如果创建一栈变量的指针很危险，栈相对于堆而言是编译器自动释放，当函数结束时，栈就会被释放，而block对象通常分配在堆上，还没有被释放，而这时候原来的指针就会变成野指针，对block而言是不安全的，&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Wed, 31 Jan 2018 17:34:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/31/block/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/31/block/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>UIWebView播放视频问题</title>
        <description>&lt;p&gt;最近的项目需求在cell中嵌套视频播放功能，视频类型主要分为用户上传到我们自己服务器的视频，和优酷，酷6等视频网站的视频。对于自己服务器上的视频链接我采用了AVFoundation框架进行播放，而一些视频网站的链接则采取UIWebView进行播放。在UIWebView的使用中遇到不少问题。
##视频无法播放问题
通常我们得到服务器传来的视频url时，直接扔到webview中时，就像下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *videoUrl = @&quot;http://v.qq.com/iframe/player.html?vid=z1411odvy7m&amp;amp;tiny=0&amp;amp;auto=1&amp;amp;allowfullscreen=\&quot;\&quot;&quot;;
NSURL *url = [NSURL URLWithString:model.videoUrl];
NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:str]];
[webView loadRequest:request]; 我发现只有个别视频可以直接播放，大多数的webview都显示白屏。总结的解决方法如下
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;1-确认地址是否含有中文或者特殊字符&quot;&gt;1. 确认地址是否含有中文，或者特殊字符&lt;/h6&gt;

&lt;p&gt;方法1：使用stringByAddingPercentEscapesUsingEncoding:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString * urlStr = [videoUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSURL *url = [NSURL URLWithString: urlStr]; 该方法已在iOS9.0中被遗弃，并且在使用中有给依然会导致url为nil。于是使用了苹果推荐的新方法，该方法最早出现在iOS7.0：

NSString * urlStr = [videoUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];
NSURL *url = [NSURL URLWithString: urlStr];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;2-确认webview是否支持该视频格式&quot;&gt;2. 确认Webview是否支持该视频格式&lt;/h6&gt;

&lt;p&gt;通过上面的格式转换后解决了大部分视频无法播放的问题。但是还使用有个别无法播放，webview显示“Not Found”，于是我怀疑是视频格式的问题，发现比较简便的方法便是：把原视频地址拷贝到手机浏览器里打开,浏览器的地址搜索栏通常具备转码功能，如果打开依然显示“Not Found”，并且视频地址在电脑上可以打开播放，则基本确定是视频格式问题。如下面这个视频地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *videoUrl = @&quot;http://player.ku6.com/refer/YV54qgeOOWsvKwwR2O_ADA../v.swf&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;视频点击播放后自动全屏&quot;&gt;视频点击播放后自动全屏&lt;/h2&gt;

&lt;p&gt;像上面的方法那样获得url后通过Webview的loadRequest方法加载视频，默认情况下会自动全屏，缩小后又自动暂停。无法在webview的小窗口内播放视频，解决方法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; webView.allowsInlineMediaPlayback = YES;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;webview清除缓存和cookie&quot;&gt;Webview清除缓存和cookie&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//清除cookies
NSHTTPCookie *cookie;
NSHTTPCookieStorage *storage = [NSHTTPCookieStorage   sharedHTTPCookieStorage];
for (cookie in [storage cookies])  {
    [storage deleteCookie:cookie];
}

//清除UIWebView的缓存
NSURLCache * cache = [NSURLCache sharedURLCache];  
[cache removeAllCachedResponses];  
[cache setDiskCapacity:0];  
[cache setMemoryCapacity:0];  

//webview暂停加载
[webView stopLoading]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

</description>
        <pubDate>Wed, 31 Jan 2018 17:30:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/31/uiwebview/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/31/uiwebview/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>mac上GitHub Desktop客户端的使用</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1640181-1ba1bcfc93e0c0cf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
通常想分享我们自己写一些酷炫的动画，或者优美的自定义控件时，大多都会想到将代码代码上传到github上，github推出客户端后，为我们提供了对github更加便捷的使用，同时还能实现versions版本控制的功能（虽然在mac上我们大多数情况下依然还是直接用git命令行的形式比较多），这里介绍下github的mac客户端上如何管理我们的代码&lt;/p&gt;

&lt;h2 id=&quot;github客户端下载&quot;&gt;&lt;strong&gt;GitHub客户端下载&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;mac客户端下载地址：&lt;a href=&quot;https://desktop.github.com&quot;&gt;desktop.github.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;安装完后启动客户端，在程序的preference(偏好设置)中选择Account并登陆你的github账号便可成功关联。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;github-desktop的使用&quot;&gt;&lt;strong&gt;GitHub Desktop的使用&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;将代码先导入到github desktop中管理&lt;/strong&gt;
左上角“+”号 -&amp;gt;选择“add”选项-&amp;gt;点击“choose..”-&amp;gt;选择上传文件,点击Open-&amp;gt;点击Create&amp;amp;Add Reposiroty(创建仓库)
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1640181-2612569329d99729.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;创建完后能在客户端的左侧的仓库列表中看到Other的目录下有我们刚上传的项目，并且前面是一个电脑的图标，表示当前项目只是存在本地电脑上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;将仓库同步到github服务器上&lt;/strong&gt;
在左侧的列表中选择我们刚创建的仓库，点击页面右上角的”Publish”(发布)，输入代码的名称以及文字描述，确认下面选择的是你要上传的账号。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1640181-0dd01fed38f55ae4.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;在等待服务器上传完之后发现左侧的列表中项目从Other栏下进入了Github栏下，现在我们在github的网站上便可找到我们新建的仓库，我们可以右键我们的项目，选择第一个View On GitHub。（这一步只是提交了仓库，但是代码还没有提交。）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;提交代码&lt;/strong&gt;
选中我们的项目后，在中间下方输入一下提交描述，（xcode中的git也是，每次提交都要必须要写一下，不写不让上传）
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1640181-fff3ae09b258ec88.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;提交完成后，原本提示的14Changes消失了，中间的列表变成了提交记录。在github上便能看到代码 &lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1640181-cceb4da6fa9b3708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt; 其他说明：
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;客户端右上角的圆圈表示提交记录时间点，其中最右边分裂成4个弧的大圆表示当前状态&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;圆之间的线段的长短与提交的时间差成正比&lt;/li&gt;
  &lt;li&gt;可以点击某个圆后，在中间的列表中点开数字，可以查看具体提交或文件修改的内容&lt;/li&gt;
  &lt;li&gt;每次有新的内容想要提交时，可以点击右上角最右边的大圆，或者中上方两个大按钮中“history”左侧的按钮。之后填写描述后点commit即可。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果提交完后到网页上没有发现上传的代码，可以在客户端上查看右上角的是Public还是Sync，如果还是Public可以多点几次，直到变成Sync才表示代码已经上传。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;代码下载&lt;/strong&gt;
GitHub Desktop客户端除了可以上传外，也可以下载你账号下创建的仓库和你fork的一些开源项目。通过这一点可以实现办公室和家里代码同步，实现versions的功能。具体操作如下：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1640181-7acc8a6ff87d5666.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;Clone下的选项中为当前关联的账号中还没有还没有导入到本地电脑的项目。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;删除仓库&lt;/strong&gt;
想要把某个仓库删除，仅仅在客户端上通过邮件项目remove是不够的，这需要到网页上执行。来到项目首页，默认是code界面，我们选择最后一个Settings，然后把页面滑到最下面，选择红色框框中最后一条“Delete this repository”，点击按钮后，输入一遍这个要删除的仓库的名字（不区分大小写），然后点击最下面的按钮“I understand the consequences，delete the repository”后就删除成功了&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;相关文章&quot;&gt;&lt;strong&gt;相关文章&lt;/strong&gt;&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/desktop/guides/getting-started/&quot;&gt;Getting Started with GitHub Desktop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/desktop/guides/contributing/&quot;&gt;Contributing to Projects with GitHub Desktop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/20070065&quot;&gt;知乎上关于github的详细学习总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

</description>
        <pubDate>Wed, 31 Jan 2018 17:29:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/31/githubdesktop/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/31/githubdesktop/</guid>
        
        <category>mac工具</category>
        
        
      </item>
    
      <item>
        <title>My own website is on</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;First Blog&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;bla-bla-bla&quot;&gt;「bla bla bla」&lt;/h3&gt;

&lt;p&gt;可喜可贺 可喜可贺&lt;/p&gt;

&lt;p&gt;捣鼓了一天 终于可以试着写第一篇博客了，其实说是日志更好。&lt;/p&gt;

&lt;p&gt;年前项目的最后一个版本总算上线了，离放假还有两个星期，除去改改小bug，有大把时光不知道怎么消磨。终于狠下心，用github-page+jekyll
整一个自己的网站。都说是傻瓜式，可是看别人的博客讲述都是大长篇，总是提不起兴趣。搞了一天后，确实流程很傻瓜。&lt;/p&gt;

&lt;p&gt;搭建的目的仅仅是想找一个既能写博客记录学到的经验，又能有个地方分享日常（估计将来都是日常）
之后闲的时间把以前的博客搬运过来&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;what-i-do&quot;&gt;「what i do」&lt;/h3&gt;

&lt;p&gt;编程的乐趣就是当看到作品在你面前运行起来的时候的成就感&lt;/p&gt;

&lt;p&gt;如果你也想搭一个这样的简单的站点，只需要做简单的准备工作：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;会一丢丢markdown语法用于写文章（真不会也没关系 只要会敲回车 就算会一种语法了）&lt;/li&gt;
  &lt;li&gt;有个github账号，创建一个github-page的项目&lt;/li&gt;
  &lt;li&gt;寻找他人使用了Jekyll模板的源码下载后覆盖在项目中，然后更具Jekyll简单配置一些网站参数&lt;/li&gt;
  &lt;li&gt;可以分享啦&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;maybe-used&quot;&gt;「maybe used」&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lady_zhou/article/details/52041098&quot;&gt;使用Github+Jekyll制作自己的博客&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/Huxpro/huxblog-boilerplate&quot;&gt;我使用的Jekyll模板&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io/blob/master/README.zh.md&quot;&gt;模板的参数配置&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;/about/index.html&quot;&gt;如有问题也联系我&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Mon, 29 Jan 2018 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/29/helloworld/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/29/helloworld/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
